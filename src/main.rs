use std::fs;
use std::io::{self, Write};
use std::path::Path;
use regex::Regex;

#[derive(Debug)]
struct TodoItem {
    file_path: String,
    line_number: usize,
    content: String,
}

fn main() -> io::Result<()> {
    let args: Vec<String> = std::env::args().collect();
    let target_dir = if args.len() > 1 {
        &args[1]
    } else {
        "."
    };
    println!("üîç Scanning for TODO comments in: {}", target_dir);

    let todos = scan_directory(Path::new(target_dir))?;
    println!("‚úÖ Found {} TODO items", todos.len());
    generate_todo_file(&todos)?;
    println!("üìù TODO.md has been generated!");

    Ok(())
}

fn scan_directory(dir: &Path) -> io::Result<Vec<TodoItem>> {
    let mut todos = Vec::new();

    let todo_regex = Regex::new(r"(//|#)(?i)(TODO|FIXME|HACK|XXX|NOTE|BUG)(:|\s*)(\s*|:)(.+)").unwrap();

    // Extensions de fichiers √† scanner
    let extensions = vec!["rs", "js", "ts", "py", "java", "c", "cpp", "go", "rb", "php", "html", "css", "jsx", "tsx", "vue"];

    visit_dirs(dir, &mut todos, &todo_regex, &extensions)?;

    // Trier par fichier puis par ligne
    todos.sort_by(|a, b| {
        a.file_path.cmp(&b.file_path)
            .then(a.line_number.cmp(&b.line_number))
    });

    Ok(todos)
}

fn visit_dirs(
    dir: &Path,
    todos: &mut Vec<TodoItem>,
    regex: &Regex,
    extensions: &[&str],
) -> io::Result<()> {
    if dir.is_dir() {
        // Ignorer certains dossiers
        let dir_name = dir.file_name()
            .and_then(|n| n.to_str())
            .unwrap_or("");

        if should_skip_dir(dir_name) {
            return Ok(());
        }

        for entry in fs::read_dir(dir)? {
            let entry = entry?;
            let path = entry.path();

            if path.is_dir() {
                visit_dirs(&path, todos, regex, extensions)?;
            } else if let Some(ext) = path.extension() {
                if extensions.contains(&ext.to_str().unwrap_or("")) {
                    scan_file(&path, todos, regex)?;
                }
            }
        }
    }
    Ok(())
}

fn should_skip_dir(dir_name: &str) -> bool {
    matches!(
        dir_name,
        "node_modules" | "target" | ".git" | "dist" | "build" | ".next" | "__pycache__" | "vendor"
    )
}

fn scan_file(path: &Path, todos: &mut Vec<TodoItem>, regex: &Regex) -> io::Result<()> {
    let content = fs::read_to_string(path)?;
    for (line_num, line) in content.lines().enumerate() {
        if let Some(caps) = regex.captures(line) {
            let tag = caps.get(2).unwrap().as_str();
            let description = caps.get(5).unwrap().as_str().trim();

            todos.push(TodoItem {
                file_path: path.to_string_lossy().to_string(),
                line_number: line_num + 1,
                content: format!("[{}] {}", tag, description),
            });
        }
    }

    Ok(())
}

fn generate_todo_file(todos: &[TodoItem]) -> io::Result<()> {
    let mut file = fs::File::create("TODO.md")?;

    writeln!(file, "# üìã TODO List")?;
    writeln!(file)?;
    writeln!(file, "This file was automatically generated by scanning the project for TODO comments.")?;
    writeln!(file)?;
    writeln!(file, "**Total items found:** {}", todos.len())?;
    writeln!(file)?;
    writeln!(file, "---")?;
    writeln!(file)?;

    // Grouper par fichier
    let mut current_file = String::new();

    for todo in todos {
        if todo.file_path != current_file {
            current_file = todo.file_path.clone();
            writeln!(file)?;
            writeln!(file, "### üìÅ `{}`", current_file)?;
            writeln!(file)?;
        }

        writeln!(
            file,
            "- [ ] **Line {}:** {}",
            todo.line_number,
            todo.content
        )?;
    }

    Ok(())
}


//TODO caca